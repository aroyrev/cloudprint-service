From 7827b6939b79237081407c591b41b5d1f37ab97d Mon Sep 17 00:00:00 2001
From: Richard van der Hoff <git@rvanderhoff.org.uk>
Date: Sun, 24 Mar 2013 00:32:39 +0000
Subject: [PATCH 05/20] reimplement XMPP connection

This commit reworks the way that the XMPP connection takes place; in
particular, we replace iterparse with our own XML event handler, which allows
us to poll for messages without blocking on the socket.

This has several benefits:

    - it allows us to more easily implement polling of jobs via the REST API
      (which is necessary for some users for whom XMPP notifications are
      unreliable - issue #48)

    - it allows us to better monitor the state of the XMPP connection, and
      reconnect it if it should fail - issue #41

    - rather than establishing a new connection between each job, we can use
      one long-running connection, which eliminates the race condition whereby
      jobs may arrive between polling the REST API and establishing the XMPP
      connection
---
 cloudprint/cloudprint.py | 204 +++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 178 insertions(+), 26 deletions(-)

diff --git a/cloudprint/cloudprint.py b/cloudprint/cloudprint.py
index 8c8c4b5..2d288c8 100755
--- a/cloudprint/cloudprint.py
+++ b/cloudprint/cloudprint.py
@@ -17,11 +17,21 @@ import logging
 import logging.handlers
 
 
+XMPP_SERVER_HOST = 'talk.google.com'
+XMPP_USE_SSL = True
+XMPP_SERVER_PORT = 5223
+#XMPP_SERVER_HOST = 'localhost'
+#XMPP_USE_SSL = False
+
 SOURCE = 'Armooo-PrintProxy-1'
 PRINT_CLOUD_SERVICE_ID = 'cloudprint'
 CLIENT_LOGIN_URL = '/accounts/ClientLogin'
 PRINT_CLOUD_URL = '/cloudprint/'
 
+# period in seconds with which we should poll for new jobs via the HTTP api.
+# 'None' to poll only on startup and when we get XMPP notifications.
+POLL_PERIOD=30.0
+
 LOGGER = logging.getLogger('cloudprint')
 LOGGER.setLevel(logging.INFO)
 
@@ -247,6 +257,7 @@ class PrinterProxy(object):
         self.name = name
 
     def get_jobs(self):
+        LOGGER.info('Polling for jobs on ' + self.name)
         return self.cpp.get_jobs(self.id)
 
     def update(self, description, ppd):
@@ -338,40 +349,181 @@ def process_job(cups_connection, cpp, printer, job):
         LOGGER.error('ERROR ' + job['title'].encode('unicode-escape'))
 
 def process_jobs(cups_connection, cpp, printers):
+    xmpp_auth = file(cpp.xmpp_auth_path).read()
+    xmpp_conn = XmppConnection()
+
     while True:
         try:
+            if not xmpp_conn.isConnected():
+                xmpp_conn.connect(xmpp_auth)
+
             for printer in printers:
-                for job in printer.get_jobs():
+                 for job in printer.get_jobs():
                     process_job(cups_connection, cpp, printer, job)
-            wait_for_new_job(file(cpp.xmpp_auth_path).read())
+            sleeptime = POLL_PERIOD
+
+            xmpp_conn.awaitNotification(sleeptime)
+
         except Exception, e:
             LOGGER.exception('ERROR: Could not Connect to Cloud Service. Will Try again in 60 Seconds')
             time.sleep(60)
 
-def wait_for_new_job(sasl_token):
-    # https://developers.google.com/cloud-print/docs/rawxmpp
-    import ssl, socket
-    from xml.etree.ElementTree import iterparse, tostring
-    xmpp = ssl.wrap_socket(socket.socket())
-    xmpp.connect(('talk.google.com', 5223))
-    parser = iterparse(xmpp, ('start', 'end'))
-    def msg(msg=' '):
-        xmpp.write(msg)
-        stack = 0
-        for event, el in parser:
-            if event == 'start' and el.tag.endswith('stream'):
-                continue
-            stack += 1 if event == 'start' else -1
-            if stack == 0:
-                assert not el.tag.endswith('failure') and not el.tag.endswith('error') and not el.get('type') == 'error', tostring(el)
-                return el
-    msg('<stream to="gmail.com" version="1.0" xmlns="http://etherx.jabber.org/streams">')
-    msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN">%s</auth>' % sasl_token)
-    msg('<s:stream to="gmail.com" version="1.0" xmlns:s="http://etherx.jabber.org/streams" xmlns="jabber:client">')
-    iq = msg('<iq type="set"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
-    bare_jid = iq[0][0].text.split('/')[0]
-    msg('<iq type="set" to="%s"><subscribe xmlns="google:push"><item channel="cloudprint.google.com" from="cloudprint.google.com"/></subscribe></iq>' % bare_jid)
-    return msg()
+
+class XmppXmlHandler(object):
+    STREAM_TAG='{http://etherx.jabber.org/streams}stream'
+
+    def __init__(self):
+        from collections import deque
+        from xml.etree.ElementTree import TreeBuilder
+        self._stack = 0
+        self._builder = TreeBuilder()
+        self._results = deque()
+
+    def data(self,data):
+        self._builder.data(data)
+
+    def start(self, tag, attrib):
+        if tag == self.STREAM_TAG:
+            return
+
+        self._builder.start(tag, attrib)
+        self._stack += 1
+
+    def end(self, tag):
+        self._stack -= 1
+        elem = self._builder.end(tag)
+
+        if self._stack == 0:
+            self._results.append(elem)
+
+    """If a top-level XML element has been completed since the last call to
+    getElem, return it; else return None."""
+    def getElem(self):
+        try:
+            return self._results.popleft()
+        except IndexError:
+            return None
+
+# https://developers.google.com/cloud-print/docs/rawxmpp
+import ssl, socket, select
+class XmppConnection(object):
+    def __init__(self):
+        self._connected = False
+        self._wrappedsock = None
+
+
+    """read pending data from the socket, and send it to the XML parser.
+
+    return False if the socket is closed, True if it is ok"""
+    def _readSocket(self):
+        data = self._wrappedsock.recv(1024)
+        if not data:
+            # socket closed
+            return False
+        else:
+            LOGGER.debug('<<< %s' % data)
+            self._xmlparser.feed(data)
+            return True
+
+    """write a message to the XMPP server"""
+    def _writeSocket(self,msg):
+        LOGGER.debug('>>> %s' % msg)
+        self._wrappedsock.send(msg)
+
+
+    """send a message to the XMPP server, and wait for a response
+
+    returns the XML element tree of the response"""
+    def _msg(self,msg=None):
+        if msg is not None:
+            self._writeSocket(msg)
+
+        while True:
+            elem = self._handler.getElem()
+
+            if elem is not None:
+                assert not elem.tag.endswith('failure') and not elem.tag.endswith('error')
+                return elem
+
+            # need more data; block until it becomes available
+            if not self._readSocket():
+                self.close()
+                raise Error("socket closed while negotiating connection")
+
+
+    """Check for any notifications which have already been received"""
+    def _checkForNotification(self):
+        return self._handler.getElem() is not None
+
+
+    """Establish a new connection to the XMPP server"""
+    def connect(self,sasl_token):
+        from xml.etree.ElementTree import XMLParser, TreeBuilder
+
+        # first close any existing socket
+        self.close()
+
+        LOGGER.info("Establishing connection to xmpp server %s:%i" % 
+                    (XMPP_SERVER_HOST, XMPP_SERVER_PORT))
+        self._xmppsock = socket.socket()
+        if XMPP_USE_SSL:
+            self._wrappedsock = ssl.wrap_socket(self._xmppsock)
+        else:
+            self._wrappedsock = self._xmppsock
+        self._wrappedsock.connect((XMPP_SERVER_HOST, XMPP_SERVER_PORT))
+
+        self._handler = XmppXmlHandler()
+        self._xmlparser = XMLParser(target=self._handler)
+
+        self._msg('<stream to="gmail.com" version="1.0" xmlns="http://etherx.jabber.org/streams">')
+        self._msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN">%s</auth>' % sasl_token)
+        self._msg('<s:stream to="gmail.com" version="1.0" xmlns:s="http://etherx.jabber.org/streams" xmlns="jabber:client">')
+        iq = self._msg('<iq type="set"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
+        bare_jid = iq[0][0].text.split('/')[0]
+        self._msg('<iq type="set" to="%s"><subscribe xmlns="google:push"><item channel="cloudprint.google.com" from="cloudprint.google.com"/></subscribe></iq>' % bare_jid)
+
+        LOGGER.info("xmpp connection established")
+        self._connected = True
+
+
+    """Close the connection to the XMPP server"""
+    def close(self):
+        if self._wrappedsock is not None:
+            self._wrappedsock.close()
+            self._wrappedsock = None
+        self._connected = False
+
+
+    """Check if we are connected to the XMPP server
+
+    returns true if the connection is active; false otherwise"""
+    def isConnected(self):
+        return self._connected
+
+
+    """wait for a timeout or event notification"""
+    def awaitNotification(self, timeout):
+        if self._checkForNotification():
+            return
+
+        sock = self._xmppsock
+        r, w, e = select.select([sock], [], [sock], timeout)
+        ok = True
+        if sock in r:
+            ok = self._readSocket()
+
+        if (not ok) or sock in e:
+            LOGGER.warn("Error in xmpp connection")
+            self.close()
+            return
+
+        # for now at least, we don't distinguish between a timeout and a
+        # notification. ultimately we might return something different here if
+        # we get a notification
+        self._checkForNotification()
+
+        return
+
 
 def usage():
     print sys.argv[0] + ' [-d][-l][-h] [-p pid_file] [-a account_file]'
-- 
1.8.4.rc3

