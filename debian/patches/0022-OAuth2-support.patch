From: David Steele <dsteele@gmail.com>
Date: Sat, 30 May 2015 08:32:19 -0400
Subject: OAuth2 support

A new module, cpoauth.py, auth changes to xmpp and rest, and substantial
changes to cloudprint.py. The cpoauth module can also be run as a script
for offline authentication.

Conflicts:
	cloudprint/cloudprint.py
	setup.py
---
 cloudprint/cloudprint.py | 173 +++++++++++++++++++----------------------------
 cloudprint/cpoauth.py    | 172 ++++++++++++++++++++++++++++++++++++++++++++++
 cloudprint/rest.py       |   2 +-
 cloudprint/xmpp.py       |   6 +-
 setup.py                 |   1 +
 5 files changed, 246 insertions(+), 108 deletions(-)
 create mode 100755 cloudprint/cpoauth.py

diff --git a/cloudprint/cloudprint.py b/cloudprint/cloudprint.py
index 1c2222c..44bd6df 100755
--- a/cloudprint/cloudprint.py
+++ b/cloudprint/cloudprint.py
@@ -16,7 +16,6 @@
 # You should have received a copy of the GNU General Public License
 # along with cloudprint.  If not, see <http://www.gnu.org/licenses/>.
 
-import rest
 import platform
 import cups
 import hashlib
@@ -34,7 +33,11 @@ import re
 import logging
 import logging.handlers
 
+import rest
 import xmpp
+import cpoauth
+
+from collections import namedtuple
 
 XMPP_SERVER_HOST = 'talk.google.com'
 XMPP_USE_SSL = True
@@ -69,113 +72,71 @@ class CloudPrintProxy(object):
 
     def __init__(self, verbose=True):
         self.verbose = verbose
-        self.auth = None
         self.cups= cups.Connection()
         self.proxy =  platform.node() + '-Armooo-PrintProxy'
         self.auth_path = os.path.expanduser('~/.cloudprintauth')
-        self.xmpp_auth_path = os.path.expanduser('~/.cloudprintauth.sasl')
         self.username = None
-        self.password = None
         self.sleeptime = 0
-        self.storepw = False
         self.include = []
         self.exclude = []
 
-    def get_auth(self):
-        if self.auth:
-            return self.auth
-        if not self.auth:
-            auth = self.get_saved_auth()
-            if auth:
-                return auth
-
-            r = rest.REST('https://www.google.com', debug=False)
-            try:
-                auth_response = r.post(
-                    CLIENT_LOGIN_URL,
-                    {
-                        'accountType': 'GOOGLE',
-                        'Email': self.username,
-                        'Passwd': self.password,
-                        'service': PRINT_CLOUD_SERVICE_ID,
-                        'source': SOURCE,
-                    },
-                    'application/x-www-form-urlencoded')
-                xmpp_response = r.post(CLIENT_LOGIN_URL,
-                    {
-                        'accountType': 'GOOGLE',
-                        'Email': self.username,
-                        'Passwd': self.password,
-                        'service': 'mail',
-                        'source': SOURCE,
-                    },
-                    'application/x-www-form-urlencoded')
-                jid = self.username if '@' in self.username else self.username + '@gmail.com'
-                sasl_token = ('\0%s\0%s' % (jid, xmpp_response['Auth'])).encode('base64')
-                file(self.xmpp_auth_path, 'w').write(sasl_token)
-            except rest.REST.RESTException, e:
-                if 'InvalidSecondFactor' in e.msg:
-                    raise rest.REST.RESTException(
-                        '2-Step',
-                        '403',
-                        'You have 2-Step authentication enabled on your '
-                        'account. \n\nPlease visit '
-                        'https://www.google.com/accounts/IssuedAuthSubTokens '
-                        'to generate an application-specific password.'
-                    )
-                else:
-                    raise
-
-            self.set_auth(auth_response['Auth'])
-            return self.auth
+    def get_auth(self, dologin=False):
+        auth = self.get_saved_auth()
+        if auth:
+            auth = self.auth_update_access(auth)
+            self.set_auth(auth)
+            return auth
+
+        if dologin:
+            oauth = cpoauth.CPOAuth()
+            access, refresh = oauth.generate_tokens(self.username)
+
+            auth = namedtuple('Auth', ['login', 'access', 'refresh'])
+            auth.login = self.username
+            auth.access = access
+            auth.refresh = refresh
+
+            self.set_auth(auth)
+            return auth
+        else:
+            raise
+
+    def auth_update_access(self, auth):
+
+        oauth = cpoauth.CPOAuth()
+        access = oauth.get_access_from_refresh(auth.refresh)
+        auth.access = access
+
+        return auth
 
     def get_saved_auth(self):
         if os.path.exists(self.auth_path):
             auth_file = open(self.auth_path)
-            self.auth = auth_file.readline().rstrip()
-            self.username = auth_file.readline().rstrip()
-            self.password = auth_file.readline().rstrip()
+
+            auth = namedtuple('Auth', ['login', 'access', 'refresh'])
+            auth.login = auth_file.readline().rstrip()
+            auth.access = auth_file.readline().rstrip()
+            auth.refresh = auth_file.readline().rstrip()
+
             auth_file.close()
-            return self.auth
+            return auth
 
     def del_saved_auth(self):
         if os.path.exists(self.auth_path):
             os.unlink(self.auth_path)
 
     def set_auth(self, auth):
-            self.auth = auth
             if not os.path.exists(self.auth_path):
                 auth_file = open(self.auth_path, 'w')
                 os.chmod(self.auth_path, stat.S_IRUSR | stat.S_IWUSR)
                 auth_file.close()
             auth_file = open(self.auth_path, 'w')
-            auth_file.write(self.auth)
-            if self.storepw:
-                auth_file.write("\n%s\n%s\n" % (self.username, self.password))
+            auth_file.write("%s\n%s\n%s\n" % (auth.login, auth.access, auth.refresh))
             auth_file.close()
 
     def get_rest(self):
-        class check_new_auth(object):
-            def __init__(self, rest):
-                self.rest = rest
-
-            def __getattr__(in_self, key):
-                attr = getattr(in_self.rest, key)
-                if not attr:
-                    raise AttributeError()
-                if not hasattr(attr, '__call__'):
-                    return attr
-
-                def f(*arg, **karg):
-                    r = attr(*arg, **karg)
-                    if 'update-client-auth' in r.headers:
-                        LOGGER.info("Updating authentication token")
-                        self.set_auth(r.headers['update-client-auth'])
-                    return r
-                return f
-
         auth = self.get_auth()
-        return check_new_auth(rest.REST('https://www.google.com', auth=auth, debug=False))
+        return rest.REST('https://www.google.com', auth=auth, debug=False)
 
     def get_printers(self):
         r = self.get_rest()
@@ -372,10 +333,11 @@ def sync_printers(cups_connection, cpp):
 
 def process_job(cups_connection, cpp, printer, job):
     global num_retries
+    access = cpp.get_auth().access
 
     request = urllib2.Request(job['fileUrl'], headers={
         'X-CloudPrint-Proxy' : 'ArmoooIsAnOEM',
-        'Authorization' : 'GoogleLogin auth=%s' % cpp.get_auth()
+        'Authorization' : "OAuth %s" % access
     })
 
     try:
@@ -386,7 +348,7 @@ def process_job(cups_connection, cpp, printer, job):
 
         request = urllib2.Request(job['ticketUrl'], headers={
             'X-CloudPrint-Proxy' : 'ArmoooIsAnOEM',
-            'Authorization' : 'GoogleLogin auth=%s' % cpp.get_auth()
+            'Authorization' : "OAuth %s" % access
         })
         options = json.loads(urllib2.urlopen(request).read())
         if 'request' in options: del options['request']
@@ -411,7 +373,6 @@ def process_job(cups_connection, cpp, printer, job):
             LOGGER.info('Job %s failed - Will retry' % job['title'].encode('unicode-escape'))
 
 def process_jobs(cups_connection, cpp, printers):
-    xmpp_auth = file(cpp.xmpp_auth_path).read()
     xmpp_conn = xmpp.XmppConnection(keepalive_period=KEEPALIVE)
 
     while True:
@@ -422,7 +383,7 @@ def process_jobs(cups_connection, cpp, printers):
 
             if not xmpp_conn.is_connected():
                 xmpp_conn.connect(XMPP_SERVER_HOST,XMPP_SERVER_PORT,
-                                  XMPP_USE_SSL,xmpp_auth)
+                                  XMPP_USE_SSL,cpp.get_auth())
 
             xmpp_conn.await_notification(cpp.sleeptime)
 
@@ -431,16 +392,6 @@ def process_jobs(cups_connection, cpp, printers):
             LOGGER.error('ERROR: Could not Connect to Cloud Service. Will Try again in %d Seconds' % FAIL_RETRY)
             time.sleep(FAIL_RETRY)
 
-        if cpp.username and not xmpp_conn.is_connected():
-            LOGGER.debug('Refreshing authentication')
-            cpp.set_auth('')
-            try:
-                cpp.get_auth()
-                xmpp_auth = file(cpp.xmpp_auth_path).read()
-            except:
-                LOGGER.debug('Error refreshing authentication')
-
-
 def main():
     parser = argparse.ArgumentParser()
     parser.add_argument('-d', dest='daemon', action='store_true',
@@ -455,14 +406,14 @@ def main():
             help='establish and store login credentials, then exit')
     parser.add_argument('-f', dest='fastpoll', action='store_true',
             help='use fast poll if notifications are not working')
-    parser.add_argument('-u', dest='storepw', action='store_true',
-            help='store username/password in addition to login token')
     parser.add_argument('-i', metavar='regexp', dest='include', default=[], action='append',
             help='include local printers matching %(metavar)s')
     parser.add_argument('-x', metavar='regexp', dest='exclude', default=[], action='append',
             help='exclude local printers matching %(metavar)s')
     parser.add_argument('-v', dest='verbose', action='store_true',
             help='verbose logging')
+    parser.add_argument('-u', dest='user', default='',
+            help='Google user')
     args = parser.parse_args()
 
     # if daemon, log to syslog, otherwise log to stdout
@@ -481,25 +432,37 @@ def main():
     cpp = CloudPrintProxy()
     if args.authfile:
         cpp.auth_path = args.authfile
-        cpp.xmpp_auth_path = args.authfile+'.sasl'
 
     cpp.sleeptime = POLL_PERIOD
     if args.fastpoll:
         cpp.sleeptime = FAST_POLL_PERIOD
 
-    if args.storepw:
-        cpp.storepw = True
-
     if args.logout:
         cpp.del_saved_auth()
         LOGGER.info('logged out')
         return
 
+    cpp.username = args.user
+
     # Check if password authentification is needed
-    if not cpp.get_saved_auth():
-        if args.authfile is None or not os.path.exists(args.authfile):
-          cpp.username = raw_input('Google username: ')
-          cpp.password = getpass.getpass()
+    needs_auth = False
+    try:
+        cpp.get_auth()
+    except:
+        needs_auth = True
+
+    if needs_auth:
+        try:
+            if not cpp.username:
+                cpp.username = raw_input('Google username: ')
+
+            if '@' not in cpp.username:
+                cpp.username += "@gmail.com"
+
+            cpp.get_auth(dologin=True)
+        except NameError:
+            print("Graphical environment needed for OAuth2 login")
+            sys.exit(-1)
 
     cpp.include = args.include
     cpp.exclude = args.exclude
@@ -517,7 +480,7 @@ def main():
             if not cpp.get_saved_auth():
                 raise
             #reset the stored auth
-            cpp.set_auth('')
+            cpp.del_saved_auth()
 
     if args.authonly:
         sys.exit(0)
diff --git a/cloudprint/cpoauth.py b/cloudprint/cpoauth.py
new file mode 100755
index 0000000..c3992f0
--- /dev/null
+++ b/cloudprint/cpoauth.py
@@ -0,0 +1,172 @@
+#!/usr/bin/python2 -tt
+#
+# Copyright 2015 David Steele <dsteele@gmail.com>
+# This file is pat of cloudprint
+# Available under the terms of the GNU General Public License version 2 or later
+#
+
+import sys
+import urllib
+import os
+import string
+import json
+import random
+
+try:
+    from gi.repository import Gtk
+    from gi.repository import Gdk
+    from gi.repository import GLib
+    from gi.repository import WebKit
+except ImportError:
+    # graphical login optional
+    pass
+
+def mute_stderr():
+    sys.stderr.flush()
+    newstderr = os.dup(2)
+    devnull = os.open(os.devnull, os.O_WRONLY)
+    os.dup2(devnull, 2)
+    os.close(devnull)
+    sys.stderr = os.fdopen(newstderr, 'w')
+
+class CPOAuth():
+    """oauth mechanism per
+          https://developers.google.com/accounts/docs/OAuth2InstalledApp
+        example at
+          http://google-mail-oauth2-tools.googlecode.com/svn/trunk/python/oauth2.py
+        Eg:
+          (access, refresh) = GMOauth().generate_tokens( "user@gmail.com" )
+    """
+
+    def __init__(self):
+        self.auth_endpoint = "https://accounts.google.com/o/oauth2/auth"
+        self.token_endpoint = "https://accounts.google.com/o/oauth2/token"
+        self.scope = "https://www.googleapis.com/auth/cloudprint https://www.googleapis.com/auth/googletalk"
+        self.client_id = "875709648124-9se38ubihuo24jbddog9r787rvlh42q1.apps.googleusercontent.com"
+        self.client_secret = "Y2No0EPTJyYgZh0MjpdM8eMH"
+        self.win_valid = False
+
+
+    def get_code(self, login_hint):
+        s=string.lowercase + string.uppercase + string.digits
+        state = ''.join(random.sample(s,10))
+
+        mute_stderr()
+
+        GLib.threads_init()
+        win = Gtk.Window()
+        win.set_title("")
+        bro = WebKit.WebView()
+
+        args = { "response_type": "code",
+             "client_id": self.client_id,
+             "redirect_uri": "urn:ietf:wg:oauth:2.0:oob",
+             "prompt": "consent",
+             "scope": self.scope,
+             "state": state,
+             "login_hint": login_hint }
+
+        code_url= "%s?%s" % (self.auth_endpoint, urllib.urlencode(args))
+
+        bro.open(code_url)
+        win.add(bro)
+        win.resize(600,600)
+
+        self.win_valid=True
+        def win_closed(window, self):
+           self.win_valid = False
+        win.connect("destroy", win_closed, self)
+
+        win.show_all()
+
+        code = None
+        count = 0
+        while self.win_valid:
+            Gtk.main_iteration_do(False)
+            bro_title = bro.get_title()
+            if not win.get_property("visible"):
+                count += 1
+                if count > 100:
+                    self.win_valid = False
+            if bro_title and state in bro_title:
+                code = bro_title.split("=")[-1]
+                win.hide()
+
+        return code
+
+    def get_token_dict(self, code):
+
+        args = { "code": code,
+             "client_id": self.client_id,
+             "client_secret": self.client_secret,
+             "redirect_uri": "urn:ietf:wg:oauth:2.0:oob",
+             "grant_type": "authorization_code",
+           }
+
+        token_page = urllib.urlopen( self.token_endpoint, urllib.urlencode(args))
+
+        return(json.loads(token_page.read()))
+
+    def get_access_from_refresh(self, refresh_token):
+
+        args = { "refresh_token": refresh_token,
+             "client_id": self.client_id,
+             "client_secret": self.client_secret,
+             "grant_type": "refresh_token",
+          }
+
+        token_page = urllib.urlopen( self.token_endpoint, urllib.urlencode(args))
+        token_dict = json.loads(token_page.read())
+
+        if "access_token" in token_dict:
+            return(token_dict["access_token"])
+        else:
+            return(None)
+
+    def generate_tokens(self, login, refresh_token=None):
+        """Generate an access token/refresh token pair for 'login' email
+           account, using an optional refresh token.
+           If refresh is not possible, the caller will be prompted for
+           authentication via an internal browser window."""
+
+        if refresh_token:
+           access_token = self.get_access_from_refresh(refresh_token)
+           if access_token:
+               return( (access_token, refresh_token) )
+
+        code = self.get_code(login)
+
+        token_dict = self.get_token_dict(code)
+
+        try:
+            return( (token_dict["access_token"], token_dict["refresh_token"]) )
+        except:
+            # todo - replace with a GG exception
+            return( (None, None) )
+
+    def access_iter(self, access, refresh, login):
+        if access:
+            yield (access, refresh)
+
+        if refresh:
+            yield (self.get_access_from_refresh(refresh), refresh)
+
+        yield self.generate_tokens(login)
+
+def main():
+    if len(sys.argv) != 2:
+        print "Usage: %s <account name>" % sys.argv[0]
+        sys.exit(-1)
+
+    login = sys.argv[1]
+    if '@' not in login:
+        login += '@gmail.com'
+
+    oauth = CPOAuth()
+    access, refresh = oauth.generate_tokens(login)
+
+    print("%s\n%s\n%s" % (login, access, refresh))
+
+if __name__ == '__main__':
+    main()
+
diff --git a/cloudprint/rest.py b/cloudprint/rest.py
index 09a5f26..448f7a6 100644
--- a/cloudprint/rest.py
+++ b/cloudprint/rest.py
@@ -77,7 +77,7 @@ class REST:
         headers['Content-Type'] = content_type + '; charset=UTF-8'
         headers['Accept-Charset'] = 'UTF-8'
         if self.auth:
-            headers['Authorization'] = 'GoogleLogin auth=%s' % self.auth
+            headers['Authorization'] = "OAuth %s" % self.auth.access
 
         self._conn.request(verb, path, data, headers)
 
diff --git a/cloudprint/xmpp.py b/cloudprint/xmpp.py
index 8304d43..3d11803 100644
--- a/cloudprint/xmpp.py
+++ b/cloudprint/xmpp.py
@@ -19,6 +19,7 @@ import ssl
 import socket
 import select
 import time
+import base64
 
 from collections import deque
 from xml.etree.ElementTree import XMLParser, TreeBuilder
@@ -122,7 +123,7 @@ class XmppConnection(object):
         self._write_socket(" ")
 
 
-    def connect(self, host, port, use_ssl, sasl_token):
+    def connect(self, host, port, use_ssl, auth):
         """Establish a new connection to the XMPP server"""
         # first close any existing socket
         self.close()
@@ -141,8 +142,9 @@ class XmppConnection(object):
             self._xmlparser = XMLParser(target=self._handler)
 
             # https://developers.google.com/cloud-print/docs/rawxmpp
+            auth_string = base64.b64encode("\0" + auth.login + "\0" + auth.access)
             self._msg('<stream:stream to="gmail.com" xml:lang="en" version="1.0" xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client">')
-            self._msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN" auth:allow-generated-jid="true" auth:client-uses-full-bind-result="true" xmlns:auth="http://www.google.com/talk/protocol/auth">%s</auth>' % sasl_token)
+            self._msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-OAUTH2" auth:service="chromiumsync" auth:allow-generated-jid="true" auth:client-uses-full-bind-result="true" xmlns:auth="http://www.google.com/talk/protocol/auth">%s</auth>' % auth_string)
             self._msg('<stream:stream to="gmail.com" xml:lang="en" version="1.0" xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client">')
             iq = self._msg('<iq type="set" id="0"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
             bare_jid = iq[0][0].text.split('/')[0]
diff --git a/setup.py b/setup.py
index d064d57..a35bee4 100644
--- a/setup.py
+++ b/setup.py
@@ -28,6 +28,7 @@ setup(
     entry_points = {
         'console_scripts': [
             'cloudprint-cmd = cloudprint.cloudprint:main',
+            'cloudprint-auth = cloudprint.cpoauth:main',
         ],
     },
 )
