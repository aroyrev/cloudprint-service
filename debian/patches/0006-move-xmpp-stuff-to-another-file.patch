From 4745caa58dee13b8313a1449c273de0fc98c44ec Mon Sep 17 00:00:00 2001
From: Richard van der Hoff <git@rvanderhoff.org.uk>
Date: Sun, 24 Mar 2013 00:58:50 +0000
Subject: [PATCH 06/20] move xmpp stuff to another file

---
 cloudprint/cloudprint.py | 163 ++---------------------------------------------
 cloudprint/xmpp.py       | 155 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 160 insertions(+), 158 deletions(-)
 create mode 100644 cloudprint/xmpp.py

diff --git a/cloudprint/cloudprint.py b/cloudprint/cloudprint.py
index 2d288c8..b4562aa 100755
--- a/cloudprint/cloudprint.py
+++ b/cloudprint/cloudprint.py
@@ -16,6 +16,7 @@ import getopt
 import logging
 import logging.handlers
 
+import xmpp
 
 XMPP_SERVER_HOST = 'talk.google.com'
 XMPP_USE_SSL = True
@@ -187,6 +188,7 @@ class CloudPrintProxy(object):
             LOGGER.info('Added Printer ' + name)
 
     def update_printer(self, printer_id, name, description, ppd):
+        return
         r = self.get_rest()
         r.post(
             PRINT_CLOUD_URL + 'update',
@@ -350,12 +352,13 @@ def process_job(cups_connection, cpp, printer, job):
 
 def process_jobs(cups_connection, cpp, printers):
     xmpp_auth = file(cpp.xmpp_auth_path).read()
-    xmpp_conn = XmppConnection()
+    xmpp_conn = xmpp.XmppConnection(LOGGER)
 
     while True:
         try:
             if not xmpp_conn.isConnected():
-                xmpp_conn.connect(xmpp_auth)
+                xmpp_conn.connect(XMPP_SERVER_HOST,XMPP_SERVER_PORT,
+                                  XMPP_USE_SSL,xmpp_auth)
 
             for printer in printers:
                  for job in printer.get_jobs():
@@ -369,162 +372,6 @@ def process_jobs(cups_connection, cpp, printers):
             time.sleep(60)
 
 
-class XmppXmlHandler(object):
-    STREAM_TAG='{http://etherx.jabber.org/streams}stream'
-
-    def __init__(self):
-        from collections import deque
-        from xml.etree.ElementTree import TreeBuilder
-        self._stack = 0
-        self._builder = TreeBuilder()
-        self._results = deque()
-
-    def data(self,data):
-        self._builder.data(data)
-
-    def start(self, tag, attrib):
-        if tag == self.STREAM_TAG:
-            return
-
-        self._builder.start(tag, attrib)
-        self._stack += 1
-
-    def end(self, tag):
-        self._stack -= 1
-        elem = self._builder.end(tag)
-
-        if self._stack == 0:
-            self._results.append(elem)
-
-    """If a top-level XML element has been completed since the last call to
-    getElem, return it; else return None."""
-    def getElem(self):
-        try:
-            return self._results.popleft()
-        except IndexError:
-            return None
-
-# https://developers.google.com/cloud-print/docs/rawxmpp
-import ssl, socket, select
-class XmppConnection(object):
-    def __init__(self):
-        self._connected = False
-        self._wrappedsock = None
-
-
-    """read pending data from the socket, and send it to the XML parser.
-
-    return False if the socket is closed, True if it is ok"""
-    def _readSocket(self):
-        data = self._wrappedsock.recv(1024)
-        if not data:
-            # socket closed
-            return False
-        else:
-            LOGGER.debug('<<< %s' % data)
-            self._xmlparser.feed(data)
-            return True
-
-    """write a message to the XMPP server"""
-    def _writeSocket(self,msg):
-        LOGGER.debug('>>> %s' % msg)
-        self._wrappedsock.send(msg)
-
-
-    """send a message to the XMPP server, and wait for a response
-
-    returns the XML element tree of the response"""
-    def _msg(self,msg=None):
-        if msg is not None:
-            self._writeSocket(msg)
-
-        while True:
-            elem = self._handler.getElem()
-
-            if elem is not None:
-                assert not elem.tag.endswith('failure') and not elem.tag.endswith('error')
-                return elem
-
-            # need more data; block until it becomes available
-            if not self._readSocket():
-                self.close()
-                raise Error("socket closed while negotiating connection")
-
-
-    """Check for any notifications which have already been received"""
-    def _checkForNotification(self):
-        return self._handler.getElem() is not None
-
-
-    """Establish a new connection to the XMPP server"""
-    def connect(self,sasl_token):
-        from xml.etree.ElementTree import XMLParser, TreeBuilder
-
-        # first close any existing socket
-        self.close()
-
-        LOGGER.info("Establishing connection to xmpp server %s:%i" % 
-                    (XMPP_SERVER_HOST, XMPP_SERVER_PORT))
-        self._xmppsock = socket.socket()
-        if XMPP_USE_SSL:
-            self._wrappedsock = ssl.wrap_socket(self._xmppsock)
-        else:
-            self._wrappedsock = self._xmppsock
-        self._wrappedsock.connect((XMPP_SERVER_HOST, XMPP_SERVER_PORT))
-
-        self._handler = XmppXmlHandler()
-        self._xmlparser = XMLParser(target=self._handler)
-
-        self._msg('<stream to="gmail.com" version="1.0" xmlns="http://etherx.jabber.org/streams">')
-        self._msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN">%s</auth>' % sasl_token)
-        self._msg('<s:stream to="gmail.com" version="1.0" xmlns:s="http://etherx.jabber.org/streams" xmlns="jabber:client">')
-        iq = self._msg('<iq type="set"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
-        bare_jid = iq[0][0].text.split('/')[0]
-        self._msg('<iq type="set" to="%s"><subscribe xmlns="google:push"><item channel="cloudprint.google.com" from="cloudprint.google.com"/></subscribe></iq>' % bare_jid)
-
-        LOGGER.info("xmpp connection established")
-        self._connected = True
-
-
-    """Close the connection to the XMPP server"""
-    def close(self):
-        if self._wrappedsock is not None:
-            self._wrappedsock.close()
-            self._wrappedsock = None
-        self._connected = False
-
-
-    """Check if we are connected to the XMPP server
-
-    returns true if the connection is active; false otherwise"""
-    def isConnected(self):
-        return self._connected
-
-
-    """wait for a timeout or event notification"""
-    def awaitNotification(self, timeout):
-        if self._checkForNotification():
-            return
-
-        sock = self._xmppsock
-        r, w, e = select.select([sock], [], [sock], timeout)
-        ok = True
-        if sock in r:
-            ok = self._readSocket()
-
-        if (not ok) or sock in e:
-            LOGGER.warn("Error in xmpp connection")
-            self.close()
-            return
-
-        # for now at least, we don't distinguish between a timeout and a
-        # notification. ultimately we might return something different here if
-        # we get a notification
-        self._checkForNotification()
-
-        return
-
-
 def usage():
     print sys.argv[0] + ' [-d][-l][-h] [-p pid_file] [-a account_file]'
     print '-d\t\t: enable daemon mode (requires the daemon module)'
diff --git a/cloudprint/xmpp.py b/cloudprint/xmpp.py
new file mode 100644
index 0000000..49c45cd
--- /dev/null
+++ b/cloudprint/xmpp.py
@@ -0,0 +1,155 @@
+import ssl
+import socket
+import select
+from collections import deque
+from xml.etree.ElementTree import XMLParser, TreeBuilder
+
+class XmppXmlHandler(object):
+    STREAM_TAG='{http://etherx.jabber.org/streams}stream'
+
+    def __init__(self):
+        self._stack = 0
+        self._builder = TreeBuilder()
+        self._results = deque()
+
+    def data(self,data):
+        self._builder.data(data)
+
+    def start(self, tag, attrib):
+        if tag == self.STREAM_TAG:
+            return
+
+        self._builder.start(tag, attrib)
+        self._stack += 1
+
+    def end(self, tag):
+        self._stack -= 1
+        elem = self._builder.end(tag)
+
+        if self._stack == 0:
+            self._results.append(elem)
+
+    """If a top-level XML element has been completed since the last call to
+    getElem, return it; else return None."""
+    def getElem(self):
+        try:
+            return self._results.popleft()
+        except IndexError:
+            return None
+
+# https://developers.google.com/cloud-print/docs/rawxmpp
+class XmppConnection(object):
+    def __init__(self, LOGGER):
+        self._connected = False
+        self._wrappedsock = None
+        self._LOGGER = LOGGER
+
+    """read pending data from the socket, and send it to the XML parser.
+
+    return False if the socket is closed, True if it is ok"""
+    def _readSocket(self):
+        data = self._wrappedsock.recv(1024)
+        if not data:
+            # socket closed
+            return False
+        else:
+            self._LOGGER.debug('<<< %s' % data)
+            self._xmlparser.feed(data)
+            return True
+
+    """write a message to the XMPP server"""
+    def _writeSocket(self,msg):
+        self._LOGGER.debug('>>> %s' % msg)
+        self._wrappedsock.send(msg)
+
+
+    """send a message to the XMPP server, and wait for a response
+
+    returns the XML element tree of the response"""
+    def _msg(self,msg=None):
+        if msg is not None:
+            self._writeSocket(msg)
+
+        while True:
+            elem = self._handler.getElem()
+
+            if elem is not None:
+                assert not elem.tag.endswith('failure') and not elem.tag.endswith('error')
+                return elem
+
+            # need more data; block until it becomes available
+            if not self._readSocket():
+                self.close()
+                raise Error("socket closed while negotiating connection")
+
+
+    """Check for any notifications which have already been received"""
+    def _checkForNotification(self):
+        return self._handler.getElem() is not None
+
+
+    """Establish a new connection to the XMPP server"""
+    def connect(self,host,port,use_ssl,sasl_token):
+        # first close any existing socket
+        self.close()
+
+        self._LOGGER.info("Establishing connection to xmpp server %s:%i" % 
+                    (host, port))
+        self._xmppsock = socket.socket()
+        if use_ssl:
+            self._wrappedsock = ssl.wrap_socket(self._xmppsock)
+        else:
+            self._wrappedsock = self._xmppsock
+        self._wrappedsock.connect((host, port))
+
+        self._handler = XmppXmlHandler()
+        self._xmlparser = XMLParser(target=self._handler)
+
+        self._msg('<stream to="gmail.com" version="1.0" xmlns="http://etherx.jabber.org/streams">')
+        self._msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN">%s</auth>' % sasl_token)
+        self._msg('<s:stream to="gmail.com" version="1.0" xmlns:s="http://etherx.jabber.org/streams" xmlns="jabber:client">')
+        iq = self._msg('<iq type="set"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
+        bare_jid = iq[0][0].text.split('/')[0]
+        self._msg('<iq type="set" to="%s"><subscribe xmlns="google:push"><item channel="cloudprint.google.com" from="cloudprint.google.com"/></subscribe></iq>' % bare_jid)
+
+        self._LOGGER.info("xmpp connection established")
+        self._connected = True
+
+
+    """Close the connection to the XMPP server"""
+    def close(self):
+        if self._wrappedsock is not None:
+            self._wrappedsock.close()
+            self._wrappedsock = None
+        self._connected = False
+
+
+    """Check if we are connected to the XMPP server
+
+    returns true if the connection is active; false otherwise"""
+    def isConnected(self):
+        return self._connected
+
+
+    """wait for a timeout or event notification"""
+    def awaitNotification(self, timeout):
+        if self._checkForNotification():
+            return
+
+        sock = self._xmppsock
+        r, w, e = select.select([sock], [], [sock], timeout)
+        ok = True
+        if sock in r:
+            ok = self._readSocket()
+
+        if (not ok) or sock in e:
+            self._LOGGER.warn("Error in xmpp connection")
+            self.close()
+            return
+
+        # for now at least, we don't distinguish between a timeout and a
+        # notification. ultimately we might return something different here if
+        # we get a notification
+        self._checkForNotification()
+
+        return
-- 
1.8.4.rc3

