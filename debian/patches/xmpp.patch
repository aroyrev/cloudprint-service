Description: Incorporate xmpp fixes from richvdh
 Experimental changes to pull out xmpp code to a
  new file, and make xmpp connections more
  persistent.
 This patch captures commit 021eb567
 https://github.com/richvdh/cloudprint
 https://github.com/armooo/cloudprint/pull/58
From: Richard van der Hoff <github@rvanderhoff.org.uk>

diff --git a/cloudprint/cloudprint.py b/cloudprint/cloudprint.py
index 88aed39..b4990da 100755
--- a/cloudprint/cloudprint.py
+++ b/cloudprint/cloudprint.py
@@ -16,14 +16,24 @@ import getopt
 import logging
 import logging.handlers
 
+import xmpp
+
+XMPP_SERVER_HOST = 'talk.google.com'
+XMPP_USE_SSL = True
+XMPP_SERVER_PORT = 5223
 
 SOURCE = 'Armooo-PrintProxy-1'
 PRINT_CLOUD_SERVICE_ID = 'cloudprint'
 CLIENT_LOGIN_URL = '/accounts/ClientLogin'
 PRINT_CLOUD_URL = '/cloudprint/'
 
+# period in seconds with which we should poll for new jobs via the HTTP api.
+# 'None' to poll only on startup and when we get XMPP notifications.
+POLL_PERIOD=30.0
+
 LOGGER = logging.getLogger('cloudprint')
 LOGGER.setLevel(logging.INFO)
+#LOGGER.setLevel(logging.DEBUG)
 
 class CloudPrintProxy(object):
 
@@ -247,6 +257,7 @@ class PrinterProxy(object):
         self.name = name
 
     def get_jobs(self):
+        LOGGER.info('Polling for jobs on ' + self.name)
         return self.cpp.get_jobs(self.id)
 
     def update(self, description, ppd):
@@ -338,40 +349,26 @@ def process_job(cups_connection, cpp, printer, job):
         LOGGER.error('ERROR ' + job['title'].encode('unicode-escape'))
 
 def process_jobs(cups_connection, cpp, printers):
+    xmpp_auth = file(cpp.xmpp_auth_path).read()
+    xmpp_conn = xmpp.XmppConnection()
+
     while True:
         try:
             for printer in printers:
                 for job in printer.get_jobs():
                     process_job(cups_connection, cpp, printer, job)
-            wait_for_new_job(file(cpp.xmpp_auth_path).read())
-        except Exception, e:
+            sleeptime = POLL_PERIOD
+
+            if not xmpp_conn.is_connected():
+                xmpp_conn.connect(XMPP_SERVER_HOST,XMPP_SERVER_PORT,
+                                  XMPP_USE_SSL,xmpp_auth)
+
+            xmpp_conn.await_notification(sleeptime)
+
+        except Exception:
             LOGGER.exception('ERROR: Could not Connect to Cloud Service. Will Try again in 60 Seconds')
             time.sleep(60)
 
-def wait_for_new_job(sasl_token):
-    # https://developers.google.com/cloud-print/docs/rawxmpp
-    import ssl, socket
-    from xml.etree.ElementTree import iterparse, tostring
-    xmpp = ssl.wrap_socket(socket.socket())
-    xmpp.connect(('talk.google.com', 5223))
-    parser = iterparse(xmpp, ('start', 'end'))
-    def msg(msg=' '):
-        xmpp.write(msg)
-        stack = 0
-        for event, el in parser:
-            if event == 'start' and el.tag.endswith('stream'):
-                continue
-            stack += 1 if event == 'start' else -1
-            if stack == 0:
-                assert not el.tag.endswith('failure') and not el.tag.endswith('error') and not el.get('type') == 'error', tostring(el)
-                return el
-    msg('<stream to="gmail.com" version="1.0" xmlns="http://etherx.jabber.org/streams">')
-    msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN">%s</auth>' % sasl_token)
-    msg('<s:stream to="gmail.com" version="1.0" xmlns:s="http://etherx.jabber.org/streams" xmlns="jabber:client">')
-    iq = msg('<iq type="set"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
-    bare_jid = iq[0][0].text.split('/')[0]
-    msg('<iq type="set" to="%s"><subscribe xmlns="google:push"><item channel="cloudprint.google.com" from="cloudprint.google.com"/></subscribe></iq>' % bare_jid)
-    return msg()
 
 def usage():
     print sys.argv[0] + ' [-d][-l][-h] [-p pid_file] [-a account_file]'
diff --git a/cloudprint/xmpp.py b/cloudprint/xmpp.py
new file mode 100644
index 0000000..26a46cb
--- /dev/null
+++ b/cloudprint/xmpp.py
@@ -0,0 +1,200 @@
+import logging
+import ssl
+import socket
+import select
+import time
+
+from collections import deque
+from xml.etree.ElementTree import XMLParser, TreeBuilder
+
+# frequency with which to send keepalives
+KEEPALIVE_PERIOD=60.0
+
+LOGGER = logging.getLogger('cloudprint.xmpp')
+
+class XmppXmlHandler(object):
+    STREAM_TAG='{http://etherx.jabber.org/streams}stream'
+
+    def __init__(self):
+        self._stack = 0
+        self._builder = TreeBuilder()
+        self._results = deque()
+
+    def data(self, data):
+        self._builder.data(data)
+
+    def start(self, tag, attrib):
+        if tag == self.STREAM_TAG:
+            return
+
+        self._builder.start(tag, attrib)
+        self._stack += 1
+
+    def end(self, tag):
+        self._stack -= 1
+        elem = self._builder.end(tag)
+
+        if self._stack == 0:
+            self._results.append(elem)
+
+    def get_elem(self):
+        """If a top-level XML element has been completed since the last call to
+        get_elem, return it; else return None."""
+        try:
+            return self._results.popleft()
+        except IndexError:
+            return None
+
+class XmppConnection(object):
+    def __init__(self):
+        self._connected = False
+        self._wrappedsock = None
+
+    def _read_socket(self):
+        """read pending data from the socket, and send it to the XML parser.
+        return False if the socket is closed, True if it is ok"""
+        try:
+            data = self._wrappedsock.recv(1024)
+            if data is None or len(data) == 0:
+                # socket closed
+                raise Exception("xmpp socket closed")
+        except Exception:
+            self._conected = False
+            raise
+
+        LOGGER.debug('<<< %s' % data)
+        self._nextkeepalive = time.time() + KEEPALIVE_PERIOD
+        self._xmlparser.feed(data)
+
+    def _write_socket(self, msg):
+        """write a message to the XMPP server"""
+        LOGGER.debug('>>> %s' % msg)
+        try:
+            self._wrappedsock.sendall(msg)
+            self._nextkeepalive = time.time() + KEEPALIVE_PERIOD
+        except Exception:
+            self._conected = False
+            raise
+
+    def _msg(self, msg=None):
+        """send a message to the XMPP server, and wait for a response
+        returns the XML element tree of the response"""
+        if msg is not None:
+            self._write_socket(msg)
+
+        while True:
+            elem = self._handler.get_elem()
+
+            if elem is not None:
+                assert not elem.tag.endswith('failure') and not elem.tag.endswith('error')
+                return elem
+
+            # need more data; block until it becomes available
+            self._read_socket()
+
+
+    def _check_for_notification(self):
+        """Check for any notifications which have already been received"""
+        return self._handler.get_elem() is not None
+
+    def _send_keepalive(self):
+        LOGGER.info("Sending XMPP keepalive")
+        self._write_socket(" ")
+
+
+    def connect(self, host, port, use_ssl, sasl_token):
+        """Establish a new connection to the XMPP server"""
+        # first close any existing socket
+        self.close()
+
+        LOGGER.info("Establishing connection to xmpp server %s:%i" % 
+                    (host, port))
+        self._xmppsock = socket.socket()
+        self._wrappedsock = self._xmppsock
+
+        try:
+            if use_ssl:
+                self._wrappedsock = ssl.wrap_socket(self._xmppsock)
+            self._wrappedsock.connect((host, port))
+
+            self._handler = XmppXmlHandler()
+            self._xmlparser = XMLParser(target=self._handler)
+
+            # https://developers.google.com/cloud-print/docs/rawxmpp
+            self._msg('<stream to="gmail.com" version="1.0" xmlns="http://etherx.jabber.org/streams">')
+            self._msg('<auth xmlns="urn:ietf:params:xml:ns:xmpp-sasl" mechanism="X-GOOGLE-TOKEN">%s</auth>' % sasl_token)
+            self._msg('<s:stream to="gmail.com" version="1.0" xmlns:s="http://etherx.jabber.org/streams" xmlns="jabber:client">')
+            iq = self._msg('<iq type="set"><bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"><resource>Armooo</resource></bind></iq>')
+            bare_jid = iq[0][0].text.split('/')[0]
+            self._msg('<iq type="set" to="%s"><subscribe xmlns="google:push"><item channel="cloudprint.google.com" from="cloudprint.google.com"/></subscribe></iq>' % bare_jid)
+        except Exception:
+            self.close()
+            raise
+
+        LOGGER.info("xmpp connection established")
+        self._connected = True
+
+
+    def close(self):
+        """Close the connection to the XMPP server"""
+        if self._wrappedsock is not None:
+            self._wrappedsock.close()
+            self._wrappedsock = None
+        self._connected = False
+        self._nextkeepalive = None
+
+
+    def is_connected(self):
+        """Check if we are connected to the XMPP server
+        returns true if the connection is active; false otherwise"""
+        return self._connected
+
+
+    def await_notification(self, timeout):
+        """wait for a timeout or event notification"""
+        now = time.time()
+
+        timeoutend = None
+        if timeout is not None:
+            timeoutend = now + timeout
+
+        while True:
+            if self._check_for_notification():
+                return True
+
+            if timeoutend is not None and timeoutend - now <= 0:
+                # timeout
+                return False
+
+            waittime = self._nextkeepalive - now
+            LOGGER.debug("%f seconds until next keepalive" % waittime)
+
+            if timeoutend is not None:
+                remaining = timeoutend - now
+                if remaining < waittime:
+                    waittime = remaining
+                    LOGGER.debug("%f seconds until timeout" % waittime)
+
+            if waittime < 0:
+                waittime = 0
+
+            sock = self._xmppsock
+            (r, w, e) = select.select([sock], [], [sock], waittime)
+
+            now = time.time()
+
+            try:
+                if self._nextkeepalive - now <= 0:
+                    self._send_keepalive()
+
+                if sock in r:
+                    self._read_socket()
+
+                if sock in e:
+                    LOGGER.warn("Error in xmpp connection")
+                    raise Exception("xmpp connection errror")
+
+            except Exception:
+                self.close()
+                raise
+
